# PentestCyprus 3.0 | rsa_tr0ubles

**Category:** Crypto **Difficulty:** Hard 

**Description:** We manage to intercept the algorithm of a communication of E-Corp employees with the main server. Our contacts tell us that this runs from a default user account in a forgotten server. Can you have a look?

nc://challenges.pentestcyprus.org:5000

https://s3.eu-central-1.amazonaws.com/pentestcyprus/crypto-4/rsa_tr0ubl3s.py

## Solution
Ok lets start by examining the description! E-Corp employees are using an algorithm to communicate with each other and that is  uses a *default user account*. By downloading the link we are prompted with the following python code:

```python
import random
import os
import base64

from Crypto.PublicKey import RSA 
from Crypto.Signature import PKCS1_v1_5 
from Crypto.Hash import SHA256 

random.seed(os.getuid())

### UTILS
def isPrime(p):
    if(p==2): return True
    if(not(p&1)): return False
    return pow(2,p-1,p)==1


def egcd(a, b):
    x,y, u,v = 0,1, 1,0
    while a != 0:
        q, r = b//a, b%a
        m, n = x-u*q, y-v*q
        b,a, x,y, u,v = a,r, u,v, m,n
        gcd = b
    return gcd, x, y


### MAIN

def getPrime(bits):
    prime = random.getrandbits(bits)
    while not isPrime(prime):
        prime = random.getrandbits(bits)
    return prime


def construct_key(p):
    q = getPrime(1024)
    n = p * q
    e = 65537

    phi = (p - 1) * (q - 1)

    # Compute modular inverse of e
    gcd, a, b = egcd(e, phi)
    d = a

    return RSA.construct((n, long(e), d, p, q))

def verify_signature(rsakey, signature, data):
    signer = PKCS1_v1_5.new(rsakey) 
    digest = SHA256.new() 

    digest.update(base64.b64decode(data))
    if signer.verify(digest, base64.b64decode(signature)):
        return True
    else:
        return False


p = getPrime(512)
indata = raw_input()
signature = raw_input()
key = construct_key(p)
if indata == 'Z2V0X2ZsYWcK' and verify_signature(key, signature, indata):
    with open('flag.txt', 'r') as f:
        print f.read()
else:
    print 'Unverified!!! Administrator has been notified!!!'
```
## Prerequisites
This challenge requires  a basic understanding on how the RSA algorithm works. More information can be found in the wikipage: https://simple.wikipedia.org/wiki/RSA_(algorithm).

Lets start reviewing the code from the main at the bottom!

```python
p = getPrime(512)
indata = raw_input()
signature = raw_input()
key = construct_key(p)
if indata == 'Z2V0X2ZsYWcK' and verify_signature(key, signature, indata):
    with open('flag.txt', 'r') as f:
        print f.read()
else:
    print 'Unverified!!! Administrator has been notified!!!'
```
We can see that the script is waiting to read from the standard input two variables, *indata*  and *signature*. It picks *"randomly"* a prime number (more on that later on), constructs the key and signs the *indata* string. It thens verifies if the indata equals to 'Z2V0X2ZsYWcK' and if the signature is correct. If these conditions are met the flag.txt file is printed in the standard output.

The RSA algorithm uses two randomly large prime numbers for its computations p and q, but in this case it creates the randomness from the uid of the user running the program! From the description we know that the script is running in a remote server on a default user account. Could be root? Lets try! ;)

To export the private key of the root user we just add the exportKey function that generates the key in PEM format and run the program as root.
```python
.
.

key = construct_key(p)
#New Code - Export Private Key
private_key = key.exportKey("PEM")
print private_key 
#######
if indata == 'Z2V0X2ZsYWcK' and verify_signature(key, signature, indata):

.
.
```
By running the modified script we get the following private key:

```
-----BEGIN RSA PRIVATE KEY-----
MIIDXgIBAAKBwQCuE4xCLKix8/6PuOEguAW/riumlZKsIUC8ayt/HfZjgI6hTMf2
B9q9ZI7k/MSrHGhulF9FIGg1Drgy9zvVQNVk5G8NApRCgnqJqPt53VGKq2RMk1/e
YzTynuf5ZniGF+t+tx/bKYonPhOYj6wup7/hP+YfmzwcEfbny70P7+9zZEqSLu4K
3Vt7/JO89Yke1PS8g/rAyorMK2HMA3WsJ+1Ssy1Omrkiv9rj83sfxwIfe7oK6cq4
J3l53ZecCd82XOUCAwEAAQKBwBv85pspJQJfkXk4J3IkREBaV4hUGh30xrzEmly4
y4mZ/NSwTKIhBylWRqdIgLJmQeAtmNe7ayXEtRb0qzkRUH3hxBUW1DAYegjuVC8K
nWjiZ5S+LsawhitqMMxWiE+uio0nr7oY7J4nzKqWekPIBsh4xi48fYNCCVEo3CGg
UMWgnL3qh42PRsr1K1SHYVX+C6722cqZpz6GnIsroTcbnDYdAzvqeDcCFAHrUbNz
LXfHzeZ64AXddCfsi8Drc17xwQJBAMnpPr7MCvo2bKElDYQvnGVU/tqgFz5YXNWy
/VWonYMd5q0lEN57LEJ0sglUvFEV56z9ATBbinYvxC1L1ubGU7ECgYEA3LVwHOiX
PFW4a3a3oM/p9diACfjDK2Eqr4TcVcOdkPpYyNavDOcCFbO3lTcrarrvkgBWf1/I
BO2er9ckxZQy5kaCIcjD9uMmIAMSrX6+A3uUQlG6VVP6xVynfNKdgSaM6Z9PhPF7
CTusz+W2OT5Q2q9v/o3CQOJonxiYw6qcLXUCQB7ulKY2LBhY7hthychOYu9DLifg
Dq+GafJzEUxmIHtNwWEVJJhw1j74Ea5MRO1HJc7ik6QM4hFpD+zAiZOhHoECgYAd
6k3W7UPKfsfvcPj0yBmrI/w+3cP+dj4l6jk/OrN5uiUcm9TAR/OFY4WnqQGuhsYA
ISGYRDBFUrvmk5+9VBgOFFKBJ8hAB4vcXO5EK+CvcimnT5KVDDv6UlO1XIrSvZnt
9JT/rQeDOd5zk2w+mA63hX4Fn8tLpiSOI/RY2SAwHQJBAJirZSBlJTmbVN/9syFn
QrB8KbIpvdFqX7Lo+Rbb/Gb/AATwN0O4c2pJyZP75i6tHdUg+d9vr4k7/Qenqyjs
ERw=
-----END RSA PRIVATE KEY-----
```
We then save the private key and sing the *Z2V0X2ZsYWcK* message.
```python
def sign_data(private_key, data):
    '''
    param: private_key_loc Path to your private key
    param: package Data to be signed
    return: base64 encoded signature
    '''
    from Crypto.PublicKey import RSA 
    from Crypto.Signature import PKCS1_v1_5 
    from Crypto.Hash import SHA256 
    from base64 import b64encode, b64decode 
    key = open(private_key, "r").read() 
    rsakey = RSA.importKey(key) 
    signer = PKCS1_v1_5.new(rsakey) 
    digest = SHA256.new() 
    # It's being assumed the data is base64 encoded, so it's decoded before updating the digest 
    digest.update(b64decode(data)) 
    sign = signer.sign(digest) 
    return b64encode(sign)

print sign_data("private_key","Z2V0X2ZsYWcK")
```
## Rapping things Up!
Now the only thing left is to connect to the remote server with netcat and submit the two values!
```bash
$ ncat challenges.pentestcyprus.org 5000
Z2V0X2ZsYWcK
WtuqKJOuhn59PGGKN3yMHc3N44t3N9G3tgUH84W7WCvSp7cgmZaHxXjuERRTLwDMVx1LRNBPV1jDbytf6GqH+BHgsPLPNISnKxBqRkie6SpI14NATH6cNlb//1JzE9cmgU7NPBc0rbC1AaP3AUWqQXW8kquPfw4Qmg6j33+f+SOGVIRXqLYcoK5dHyadcbs+KLOeyROixX+45l/xbTmM+/TkeF929wVZx6k27qVoaW7Y5eigHPBgbk9zysBnjc4c
pency{r4nd0mness_sh0uld_b3_s3cure}
```